// ==UserScript==
// @name         Google AI Studio æ¨¡å‹æ³¨å…¥å™¨
// @namespace    http://tampermonkey.net/
// @version      1.6.5
// @description  å‘ Google AI Studio æ³¨å…¥è‡ªå®šä¹‰æ¨¡å‹ï¼Œæ”¯æŒä¸»é¢˜è¡¨æƒ…å›¾æ ‡ã€‚æ‹¦æˆª XHR/Fetch è¯·æ±‚ï¼Œå¤„ç†æ•°ç»„ç»“æ„çš„ JSON æ•°æ®
// @author       Generated by AI / HCPTangHY / Mozi / wisdgod / UserModified
// @match        https://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=aistudio.google.com
// @grant        none
// @run-at       document-start
// @license      MIT
// ==/UserScript==

(function() {
    'use strict';

    // ==================== é…ç½®åŒºåŸŸ ====================
    // è„šæœ¬å·²ç»å¤±æ•ˆ

    const SCRIPT_VERSION = "none";
    const LOG_PREFIX = `[AI Studio æ³¨å…¥å™¨ ${SCRIPT_VERSION}]`;
    const ANTI_HIJACK_PREFIX = ")]}'\n";

    // æ¨¡å‹é…ç½®åˆ—è¡¨
    // å·²æŒ‰è¦æ±‚å°† jfdksal98a æ”¾åˆ° blacktooth çš„ä¸‹é¢
    const MODELS_TO_INJECT = [

        //ä¸‹é¢æ¨¡å‹å·²ç»å…¨éƒ¨å¤±æ•ˆï¼Œç•™ä¸‹æ¥æ€€å¿µ
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-exp-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/gemini-2.5-pro-preview-06-05', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, description: `Model injected by script ${SCRIPT_VERSION}` },
        // { name: 'models/blacktooth-ab-test', displayName: `ğŸ´â€â˜ ï¸ Blacktooth (è„šæœ¬ ${SCRIPT_VERSION})`, description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹` },
        // { name: 'models/jfdksal98a', displayName: `ğŸª jfdksal98a (è„šæœ¬ ${SCRIPT_VERSION})`, description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹` },
        // { name: 'models/gemini-2.5-pro-preview-03-25', displayName: `âœ¨ Gemini 2.5 Pro 03-25 (è„šæœ¬ ${SCRIPT_VERSION})`, description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹` },
        // { name: 'models/goldmane-ab-test', displayName: `ğŸ¦ Goldmane (è„šæœ¬ ${SCRIPT_VERSION})`, description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹` },
        // { name: 'models/claybrook-ab-test', displayName: `ğŸ’§ Claybrook (è„šæœ¬ ${SCRIPT_VERSION})`, description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹` },
        // { name: 'models/frostwind-ab-test', displayName: `â„ï¸ Frostwind (è„šæœ¬ ${SCRIPT_VERSION})`, description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹` },
        // { name: 'models/calmriver-ab-test', displayName: `ğŸŒŠ Calmriver (è„šæœ¬ ${SCRIPT_VERSION})`, description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹` }
    ];

    // JSON ç»“æ„ä¸­çš„å­—æ®µç´¢å¼•
    const MODEL_FIELDS = {
        NAME: 0,
        DISPLAY_NAME: 3,
        DESCRIPTION: 4,
        METHODS: 7
    };

    // ==================== å·¥å…·å‡½æ•° ====================

    /**
     * æ£€æŸ¥ URL æ˜¯å¦ä¸ºç›®æ ‡ API ç«¯ç‚¹
     * @param {string} url - è¦æ£€æŸ¥çš„ URL
     * @returns {boolean}
     */
    function isTargetURL(url) {
        return url && typeof url === 'string' &&
               url.includes('alkalimakersuite') &&
               url.includes('/ListModels');
    }

    /**
     * é€’å½’æŸ¥æ‰¾æ¨¡å‹åˆ—è¡¨æ•°ç»„
     * @param {any} obj - è¦æœç´¢çš„å¯¹è±¡
     * @returns {Array|null} æ‰¾åˆ°çš„æ¨¡å‹æ•°ç»„æˆ– null
     */
    function findModelListArray(obj) {
        if (!obj) return null;

        // æ£€æŸ¥æ˜¯å¦ä¸ºç›®æ ‡æ¨¡å‹æ•°ç»„
        if (Array.isArray(obj) && obj.length > 0 && obj.every(
            item => Array.isArray(item) &&
                    typeof item[MODEL_FIELDS.NAME] === 'string' &&
                    String(item[MODEL_FIELDS.NAME]).startsWith('models/')
        )) {
            return obj;
        }

        // é€’å½’æœç´¢å­å¯¹è±¡
        if (typeof obj === 'object') {
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) &&
                    typeof obj[key] === 'object' &&
                    obj[key] !== null) {
                    const result = findModelListArray(obj[key]);
                    if (result) return result;
                }
            }
        }
        return null;
    }

    /**
     * æŸ¥æ‰¾åˆé€‚çš„æ¨¡æ¿æ¨¡å‹
     * @param {Array} modelsArray - æ¨¡å‹æ•°ç»„
     * @returns {Array|null} æ¨¡æ¿æ¨¡å‹æˆ– null
     */
    function findTemplateModel(modelsArray) {
        // ä¼˜å…ˆæŸ¥æ‰¾åŒ…å«ç‰¹å®šå…³é”®è¯çš„æ¨¡å‹
        const templateModel =
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('pro') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('flash') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS]));

        return templateModel;
    }

    /**
     * æ›´æ–°å·²å­˜åœ¨æ¨¡å‹çš„æ˜¾ç¤ºåç§°
     * @param {Array} existingModel - ç°æœ‰æ¨¡å‹
     * @param {Object} modelToInject - è¦æ³¨å…¥çš„æ¨¡å‹é…ç½®
     * @returns {boolean} æ˜¯å¦è¿›è¡Œäº†æ›´æ–°
     */
    function updateExistingModel(existingModel, modelToInject) {
        if (!existingModel || existingModel[MODEL_FIELDS.DISPLAY_NAME] === modelToInject.displayName) {
            return false;
        }

        // æå–åŸºç¡€åç§°ï¼ˆå»é™¤ç‰ˆæœ¬å·å’Œè¡¨æƒ…ï¼‰
        // æ›´æ–°æ­£åˆ™è¡¨è¾¾å¼ä»¥åŒ¹é… vX.Y.Z æ ¼å¼
        const cleanName = (name) => String(name)
            .replace(/ \(è„šæœ¬ v\d+\.\d+(\.\d+)?(-beta\d*)?\)/, '')
            // åŒ…å«æ‰€æœ‰å½“å‰ä½¿ç”¨çš„è¡¨æƒ…ï¼ŒåŒ…æ‹¬æ–°å¢çš„ ğŸ´â€â˜ ï¸, ğŸ¤–, ğŸª
            .replace(/^[âœ¨ğŸ¦ğŸ’§â„ï¸ğŸŒŠğŸ‰ğŸ´â€â˜ ï¸ğŸ¤–ğŸª]\s*/, '')
            .trim();

        const baseExistingName = cleanName(existingModel[MODEL_FIELDS.DISPLAY_NAME]);
        const baseInjectName = cleanName(modelToInject.displayName);

        if (baseExistingName === baseInjectName) {
            // ä»…æ›´æ–°ç‰ˆæœ¬å·å’Œè¡¨æƒ…
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
            console.log(LOG_PREFIX, `å·²æ›´æ–°è¡¨æƒ…/ç‰ˆæœ¬å·: ${modelToInject.displayName}`);
        } else {
            // æ ‡è®°ä¸ºåŸå§‹æ¨¡å‹
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName + " (åŸå§‹)";
            console.log(LOG_PREFIX, `å·²æ›´æ–°å®˜æ–¹æ¨¡å‹ ${modelToInject.name} çš„æ˜¾ç¤ºåç§°`);
        }
        return true;
    }

    /**
     * åˆ›å»ºæ–°æ¨¡å‹
     * @param {Array} templateModel - æ¨¡æ¿æ¨¡å‹
     * @param {Object} modelToInject - è¦æ³¨å…¥çš„æ¨¡å‹é…ç½®
     * @param {string} templateName - æ¨¡æ¿åç§°
     * @returns {Array} æ–°æ¨¡å‹æ•°ç»„
     */
    function createNewModel(templateModel, modelToInject, templateName) {
        const newModel = structuredClone(templateModel);

        newModel[MODEL_FIELDS.NAME] = modelToInject.name;
        newModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
        newModel[MODEL_FIELDS.DESCRIPTION] = `${modelToInject.description} (åŸºäº ${templateName} ç»“æ„)`;

        if (!Array.isArray(newModel[MODEL_FIELDS.METHODS])) {
            newModel[MODEL_FIELDS.METHODS] = [
                "generateContent",
                "countTokens",
                "createCachedContent",
                "batchGenerateContent"
            ];
        }

        return newModel;
    }

    // ==================== æ ¸å¿ƒå¤„ç†å‡½æ•° ====================

    /**
     * å¤„ç†å¹¶ä¿®æ”¹ JSON æ•°æ®
     * @param {Object} jsonData - åŸå§‹ JSON æ•°æ®
     * @param {string} url - è¯·æ±‚ URL
     * @returns {Object} åŒ…å«å¤„ç†åæ•°æ®å’Œä¿®æ”¹æ ‡å¿—çš„å¯¹è±¡
     */
    function processJsonData(jsonData, url) {
        let modificationMade = false;
        const modelsArray = findModelListArray(jsonData);

        if (!modelsArray || !Array.isArray(modelsArray)) {
            console.warn(LOG_PREFIX, 'åœ¨ JSON ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ¨¡å‹åˆ—è¡¨ç»“æ„:', url);
            return { data: jsonData, modified: false };
        }

        // æŸ¥æ‰¾æ¨¡æ¿æ¨¡å‹
        const templateModel = findTemplateModel(modelsArray);
        const templateName = templateModel?.[MODEL_FIELDS.NAME] || 'unknown';

        if (!templateModel) {
            console.warn(LOG_PREFIX, 'æœªæ‰¾åˆ°åˆé€‚çš„æ¨¡æ¿æ¨¡å‹ï¼Œæ— æ³•æ³¨å…¥æ–°æ¨¡å‹');
        }

        // åå‘éå†ä»¥ä¿æŒæ˜¾ç¤ºé¡ºåº (é…ç½®ä¸­é å‰çš„æ¨¡å‹æ˜¾ç¤ºåœ¨æœ€ä¸Šé¢)
        [...MODELS_TO_INJECT].reverse().forEach(modelToInject => {
            const existingModel = modelsArray.find(
                model => Array.isArray(model) && model[MODEL_FIELDS.NAME] === modelToInject.name
            );

            if (!existingModel) {
                // æ³¨å…¥æ–°æ¨¡å‹
                if (!templateModel) {
                    console.warn(LOG_PREFIX, `æ— æ³•æ³¨å…¥ ${modelToInject.name}ï¼šç¼ºå°‘æ¨¡æ¿`);
                    return;
                }

                const newModel = createNewModel(templateModel, modelToInject, templateName);
                modelsArray.unshift(newModel); // unshift å°†æ¨¡å‹æ·»åŠ åˆ°æ•°ç»„å¼€å¤´
                modificationMade = true;
                console.log(LOG_PREFIX, `æˆåŠŸæ³¨å…¥: ${modelToInject.displayName}`);
            } else {
                // æ›´æ–°ç°æœ‰æ¨¡å‹
                if (updateExistingModel(existingModel, modelToInject)) {
                    modificationMade = true;
                }
            }
        });

        return { data: jsonData, modified: modificationMade };
    }

    /**
     * ä¿®æ”¹å“åº”ä½“
     * @param {string} originalText - åŸå§‹å“åº”æ–‡æœ¬
     * @param {string} url - è¯·æ±‚ URL
     * @returns {string} ä¿®æ”¹åçš„å“åº”æ–‡æœ¬
     */
    function modifyResponseBody(originalText, url) {
        if (!originalText || typeof originalText !== 'string') {
            return originalText;
        }

        try {
            let textBody = originalText;
            let hasPrefix = false;

            // å¤„ç†ååŠ«æŒå‰ç¼€
            if (textBody.startsWith(ANTI_HIJACK_PREFIX)) {
                textBody = textBody.substring(ANTI_HIJACK_PREFIX.length);
                hasPrefix = true;
            }

            if (!textBody.trim()) return originalText;

            const jsonData = JSON.parse(textBody);
            const result = processJsonData(jsonData, url);

            if (result.modified) {
                let newBody = JSON.stringify(result.data);
                if (hasPrefix) {
                    newBody = ANTI_HIJACK_PREFIX + newBody;
                }
                return newBody;
            }
        } catch (error) {
            console.error(LOG_PREFIX, 'å¤„ç†å“åº”ä½“æ—¶å‡ºé”™:', url, error);
        }

        return originalText;
    }

    // ==================== è¯·æ±‚æ‹¦æˆª ====================

    // æ‹¦æˆª Fetch API
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const resource = args[0];
        const url = (resource instanceof Request) ? resource.url : String(resource);
        const response = await originalFetch.apply(this, args);

        if (isTargetURL(url) && response.ok) {
            console.log(LOG_PREFIX, '[Fetch] æ‹¦æˆªåˆ°ç›®æ ‡è¯·æ±‚:', url);
            try {
                const cloneResponse = response.clone();
                const originalText = await cloneResponse.text();
                const newBody = modifyResponseBody(originalText, url);

                if (newBody !== originalText) {
                    return new Response(newBody, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: response.headers
                    });
                }
            } catch (e) {
                console.error(LOG_PREFIX, '[Fetch] å¤„ç†é”™è¯¯:', e);
            }
        }
        return response;
    };

    // æ‹¦æˆª XMLHttpRequest
    const xhrProto = XMLHttpRequest.prototype;
    const originalOpen = xhrProto.open;
    const originalResponseTextDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'responseText');
    const originalResponseDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'response');
    let interceptionCount = 0;

    // é‡å†™ open æ–¹æ³•
    xhrProto.open = function(method, url) {
        this._interceptorUrl = url;
        this._isTargetXHR = isTargetURL(url);

        if (this._isTargetXHR) {
            interceptionCount++;
            console.log(LOG_PREFIX, `[XHR] æ£€æµ‹åˆ°ç›®æ ‡è¯·æ±‚ (${interceptionCount})ï¼š`, url);
        }

        return originalOpen.apply(this, arguments);
    };

    /**
     * å¤„ç† XHR å“åº”
     * @param {XMLHttpRequest} xhr - XHR å¯¹è±¡
     * @param {any} originalValue - åŸå§‹å“åº”å€¼
     * @param {string} type - å“åº”ç±»å‹
     * @returns {any} å¤„ç†åçš„å“åº”å€¼
     */
    const handleXHRResponse = (xhr, originalValue, type = 'text') => {
        if (!xhr._isTargetXHR || xhr.readyState !== 4 || xhr.status !== 200) {
            return originalValue;
        }

        const cacheKey = '_modifiedResponseCache_' + type;

        if (xhr[cacheKey] === undefined) {
            const originalText = (type === 'text' || typeof originalValue !== 'object' || originalValue === null)
                ? String(originalValue || '')
                : JSON.stringify(originalValue);

            xhr[cacheKey] = modifyResponseBody(originalText, xhr._interceptorUrl);
        }

        const cachedResponse = xhr[cacheKey];

        try {
            if (type === 'json' && typeof cachedResponse === 'string') {
                const textToParse = cachedResponse.replace(ANTI_HIJACK_PREFIX, '');
                return textToParse ? JSON.parse(textToParse) : null;
            }
        } catch (e) {
            console.error(LOG_PREFIX, '[XHR] è§£æç¼“å­˜çš„ JSON æ—¶å‡ºé”™:', e);
            return originalValue;
        }

        return cachedResponse;
    };

    // é‡å†™ responseText å±æ€§
    if (originalResponseTextDescriptor?.get) {
        Object.defineProperty(xhrProto, 'responseText', {
            get: function() {
                const originalText = originalResponseTextDescriptor.get.call(this);

                if (this.responseType && this.responseType !== 'text' && this.responseType !== "") {
                    return originalText;
                }

                return handleXHRResponse(this, originalText, 'text');
            },
            configurable: true
        });
    }

    // é‡å†™ response å±æ€§
    if (originalResponseDescriptor?.get) {
        Object.defineProperty(xhrProto, 'response', {
            get: function() {
                const originalResponse = originalResponseDescriptor.get.call(this);

                if (this.responseType === 'json') {
                    return handleXHRResponse(this, originalResponse, 'json');
                }

                if (!this.responseType || this.responseType === 'text' || this.responseType === "") {
                    return handleXHRResponse(this, originalResponse, 'text');
                }

                return originalResponse;
            },
            configurable: true
        });
    }

    console.log(LOG_PREFIX, 'è„šæœ¬å·²æ¿€æ´»ï¼ŒFetch å’Œ XHR æ‹¦æˆªå·²å¯ç”¨');
})();
